import logging
import urllib.parse
from typing import Dict

import aiohttp
import gidgetlab.aiohttp
import yaml

from .auth import GitLabAuthenticator, GitLabSingleUserAuthenticator

log = logging.getLogger(__name__)


class InvalidConfigYAMLError(Exception):
    pass


class GitLabClientFactory:
    def __init__(
        self,
        instance_url: str,
        requester: str,
        token: str,
        callback_url: str,
        webhook_secret: str,
        token_type: str = "impersonation",  # nosec B107
    ):
        self.requester = requester

        if token_type == "single":  # nosec B105
            self.auth = GitLabSingleUserAuthenticator(token)
        elif token_type == "impersonation":  # nosec B105
            self.auth = GitLabAuthenticator(instance_url, requester, token)
        else:
            raise ValueError(f"Unknown GitLab token type: {token_type}")

        self.instance_url = instance_url
        self.callback_url = callback_url
        self.webhook_secret = webhook_secret

    def create_client(self, user: str):
        """creates a GitLabClient for a specific user"""
        # for the destination client, the user is grabbed from the account map
        # and will ultimately authenticate with the destination instance
        # and run CI jobs as that user
        return GitLabClient(
            self.auth,
            self.instance_url,
            self.callback_url,
            self.webhook_secret,
            user,
        )


class GitLabSrcClientFactory:
    def __init__(self, instance_url, access_token, requester):
        self.auth = GitLabAuthenticator(instance_url, access_token)
        self.instance_url = instance_url
        self.requester = requester

    def create_client(self, repo_id):
        return GitLabSrcClient(self.auth, self.instance_url, self.requester, repo_id)


class GitLabClient:
    def __init__(
        self,
        auth: GitLabAuthenticator,
        instance_url: str,
        callback_url: str,
        webhook_secret: str,
        user: str,
    ):
        self.auth = auth
        self.instance_url = instance_url
        self.callback_url = callback_url
        self.webhook_secret = webhook_secret
        self.user = user

    async def set_webhook(self, gl_fullname: str, data: Dict):
        gl_token = await self.auth.authenticate_user(username=self.user)

        new_hook = {
            "token": self.webhook_secret,
            "url": f"{self.callback_url}?{urllib.parse.urlencode(data)}",
            "name": "hubcast",
            "description": "Generated by Hubcast for status reporting.",
            "job_events": True,
            "pipeline_events": True,
            "push_events": False,
        }

        async with aiohttp.ClientSession() as session:
            gl = gidgetlab.aiohttp.GitLabAPI(
                session,
                requester=self.user,
                access_token=gl_token,
                url=self.instance_url,
            )

            existing_hook = None

            repo_id = urllib.parse.quote_plus(gl_fullname)
            url = f"/projects/{repo_id}/hooks"

            hooks_data = await gl.getitem(url)
            for hook in hooks_data:
                if hook["name"] == "hubcast":
                    existing_hook = hook
                    break

            # if no existing hook is found add one and exit
            if not existing_hook:
                await gl.post(url, data=new_hook)
                return

            # if an existing hook is found compare the values of it
            # and the newly generated hook, update the hook to match
            # the new configuration if they differ
            changed = False
            for key in new_hook.keys():
                if key != "token" and existing_hook[key] != new_hook[key]:
                    changed = True
                    break

            if changed:
                url = f"/projects/{repo_id}/hooks/{existing_hook['id']}"
                await gl.put(url, data=new_hook)

    async def get_latest_pipeline(self, gl_fullname: str, ref: str) -> int:
        """gets the latest pipeline for an arbitrary GitLab repository and branch.
        Returns:
            the pipeline's id
        """

        gl_token = await self.auth.authenticate_user(self.user)

        async with aiohttp.ClientSession() as session:
            gl = gidgetlab.aiohttp.GitLabAPI(
                session,
                requester=self.user,
                access_token=gl_token,
                url=self.instance_url,
            )

            repo_id = urllib.parse.quote_plus(gl_fullname)

            pipeline = await gl.getitem(
                f"/projects/{repo_id}/pipelines/latest?ref={ref}"
            )

            return pipeline.get("id")

    async def run_pipeline(self, gl_fullname: str, ref: str) -> str:
        """(re)-run a pipeline from an arbitrary GitLab repository and branch.
        Returns:
            the new pipeline's url
        """

        gl_token = await self.auth.authenticate_user(self.user)

        async with aiohttp.ClientSession() as session:
            gl = gidgetlab.aiohttp.GitLabAPI(
                session,
                requester=self.user,
                access_token=gl_token,
                url=self.instance_url,
            )

            repo_id = urllib.parse.quote_plus(gl_fullname)

            pipeline = await gl.post(f"/projects/{repo_id}/pipeline?ref={ref}", data={})

            return pipeline.get("web_url")

    async def retry_pipeline_jobs(self, gl_fullname: str, pipeline_id: int) -> str:
        """retries any failed jobs in a pipeline. if there are no jobs that meet this criteria,
        calling this has no effect
        Returns:
            the pipeline's url
        """

        gl_token = await self.auth.authenticate_user(self.user)

        async with aiohttp.ClientSession() as session:
            gl = gidgetlab.aiohttp.GitLabAPI(
                session,
                requester=self.user,
                access_token=gl_token,
                url=self.instance_url,
            )

            repo_id = urllib.parse.quote_plus(gl_fullname)

            pipeline = await gl.post(
                f"/projects/{repo_id}/pipelines/{pipeline_id}/retry", data={}
            )

            return pipeline.get("web_url")


class GitLabSrcClient:
    def __init__(self, auth, instance_url, requester, repo_id):
        self.auth = auth
        self.instance_url = instance_url
        self.requester = requester
        self.repo_id = repo_id

    async def get_repo_config(self):
        gl_token = await self.auth.authenticate_installation(self.requester)

        async with aiohttp.ClientSession() as session:
            gl = gidgetlab.aiohttp.GitLabAPI(
                session, self.requester, access_token=gl_token, url=self.instance_url
            )

            filepath = urllib.parse.quote_plus(".github/hubcast.yml")
            url = f"/projects/{self.repo_id}/repository/files/{filepath}/raw"
            config_str = await gl.getitem(url)

            try:
                config = yaml.safe_load(config_str)
            except yaml.YAMLError as exc:
                log.error(
                    f"[{self.instance_url} -- {self.repo_id}]: Unable to parse config: {exc}"
                )
                raise InvalidConfigYAMLError()

            return config

    async def set_check_status(
        self, ref: str, check_name: str, status: str, details_url: str
    ):
        """note: this is known as 'pipeline status' in Gitlab, but we keep the same signature from the Github implementation for consistency"""
        # status can be directly mapped from gitlab->gitlab
        payload = {"name": check_name, "target_url": details_url, "state": status}

        gl_token = await self.auth.authenticate_installation(self.requester)

        async with aiohttp.ClientSession() as session:
            gl = gidgetlab.aiohttp.GitLabAPI(
                session, self.requester, access_token=gl_token, url=self.instance_url
            )

            # get a list of the current checks on a commit
            url = f"/projects/{self.repo_id}/repository/commits/{ref}/statuses"
            data = await gl.getitem(url)

            # search for existing check
            existing_check = None
            for check in data:
                if check["name"] == check_name:
                    existing_check = check
                    break

            if existing_check:
                # The ID of the pipeline to set status. Use in case of several pipeline on same SHA.
                payload["pipeline_id"] = existing_check["pipeline_id"]
            # else the status, failed, or canceled status will get forwarded

            url = f"/projects/{self.repo_id}/statuses/{ref}"
            try:
                await gl.post(url, data=payload)
            except Exception as exc:
                if "Cannot transition status" in str(exc):
                    # see https://forum.gitlab.com/t/cannot-transition-status-via-run-from-running-reason-s-status-cannot-transition-via-run/42588/7
                    # the program enters this state if the pipeline/commit status is updated to a status â‰¤ the current status
                    # for instance, setting it to pending when it's already running
                    # this also means that we can't update other parts of the payload (eg target_url) without increasing the "value" of the status
                    # i've seen this exception when gl.post() call to update the status to `running` is sent before the `pending` state
                    # we ignore the exception in this case as the user is still receiving up-to-date information about the status of their pipeline
                    # the events arrive in a jumbled order sometimes pending -> running -> created
                    pass
                else:
                    print(exc)
