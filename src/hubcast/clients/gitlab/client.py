import urllib.parse
from typing import Dict

import aiohttp
import gidgetlab.aiohttp

from .auth import GitLabAuthenticator


class GitLabClientFactory:
    def __init__(self, instance_url, access_token, callback_url, webhook_secret):
        self.auth = GitLabAuthenticator(instance_url, access_token)
        self.instance_url = instance_url
        self.callback_url = callback_url
        self.webhook_secret = webhook_secret

    def create_client(self, gitlab_user):
        # TODO: rewrite to support impersonation tokens
        # by downscoping auth token for user
        return GitLabClient(
            self.auth,
            self.instance_url,
            self.callback_url,
            self.webhook_secret,
            gitlab_user,
        )


class GitLabClient:
    def __init__(self, auth, instance_url, callback_url, webhook_secret, user):
        self.auth = auth
        self.instance_url = instance_url
        self.callback_url = callback_url
        self.webhook_secret = webhook_secret
        self.user = user

    async def set_webhook(self, gl_fullname: str, data: Dict):
        gl_token = await self.auth.authenticate_installation(self.user)

        new_hook = {
            "token": self.webhook_secret,
            "url": f"{self.callback_url}?{urllib.parse.urlencode(data)}",
            "name": "hubcast",
            "description": "Generated by Hubcast for status reporting.",
            "job_events": True,
            "pipeline_events": True,
            "push_events": False,
        }

        async with aiohttp.ClientSession() as session:
            gl = gidgetlab.aiohttp.GitLabAPI(
                session, self.user, access_token=gl_token, url=self.instance_url
            )

            existing_hook = None

            repo_id = urllib.parse.quote_plus(gl_fullname)
            url = f"/projects/{repo_id}/hooks"

            hooks_data = await gl.getitem(url)
            for hook in hooks_data:
                if hook["name"] == "hubcast":
                    existing_hook = hook
                    break

            # if no existing hook is found add one and exit
            if not existing_hook:
                await gl.post(url, data=new_hook)
                return

            # if an existing hook is found compare the values of it
            # and the newly generated hook, update the hook to match
            # the new configuration if they differ
            changed = False
            for key in new_hook.keys():
                if key != "token" and existing_hook[key] != new_hook[key]:
                    changed = True
                    break

            if changed:
                url = f"/projects/{repo_id}/hooks/{existing_hook['id']}"
                await gl.put(url, data=new_hook)

    async def get_latest_pipeline(self, gl_fullname: str, ref: str) -> int:
        """gets the latest pipeline for an arbitrary GitLab repository and branch.
        Returns:
            the pipeline's id
        """

        gl_token = await self.auth.authenticate_installation(self.user)

        async with aiohttp.ClientSession() as session:
            gl = gidgetlab.aiohttp.GitLabAPI(
                session, self.user, access_token=gl_token, url=self.instance_url
            )

            repo_id = urllib.parse.quote_plus(gl_fullname)

            pipeline = await gl.getitem(
                f"/projects/{repo_id}/pipelines/latest?ref={ref}"
            )

            return pipeline.get("id")

    async def run_pipeline(self, gl_fullname: str, ref: str) -> str:
        """(re)-run a pipeline from an arbitrary GitLab repository and branch.
        Returns:
            the new pipeline's url
        """

        gl_token = await self.auth.authenticate_installation(self.user)

        async with aiohttp.ClientSession() as session:
            gl = gidgetlab.aiohttp.GitLabAPI(
                session, self.user, access_token=gl_token, url=self.instance_url
            )

            repo_id = urllib.parse.quote_plus(gl_fullname)

            pipeline = await gl.post(f"/projects/{repo_id}/pipeline?ref={ref}", data={})

            return pipeline.get("web_url")

    async def retry_pipeline_jobs(self, gl_fullname: str, pipeline_id: int) -> str:
        """retries any failed jobs in a pipeline. if there are no jobs that meet this criteria,
        calling this has no effect
        Returns:
            the pipeline's url
        """

        gl_token = await self.auth.authenticate_installation(self.user)

        async with aiohttp.ClientSession() as session:
            gl = gidgetlab.aiohttp.GitLabAPI(
                session, self.user, access_token=gl_token, url=self.instance_url
            )

            repo_id = urllib.parse.quote_plus(gl_fullname)

            pipeline = await gl.post(
                f"/projects/{repo_id}/pipelines/{pipeline_id}/retry", data={}
            )

            return pipeline.get("web_url")
